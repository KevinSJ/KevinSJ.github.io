import{Q as E}from"./index-0c1fde36.js";var j={},c={};Object.defineProperty(c,"__esModule",{value:!0});c.IPMask=c.IPSubnetwork=c.IPRange=c.partsToIP=c.getIP=c.IPv6=c.IPv4=c.IPMatch=c.getMatch=void 0;const $=/^(\d{1,3}\.|\*\.){3}(\d{1,3}|\*)$/,F=/^((([a-f\d]{1,4}|\*)::?)+([a-f\d]{1,4}|\*)|:(:[a-f\d]{1,4}|:\*)+|([a-f\d]{1,4}:|\*:)+:|::)$/i,M=/(.*):((?:\d{1,3}\.|\*\.){3}(\d{1,3}|\*))$/;function q(r,t=10){return e=>{if(e==="*")return-1;const n=parseInt(e,t);if(n<0||n>r)throw new Error(`Value has to be in the range of 0-${r}`);return n}}function A(r,t){const e=[];for(;t--;)e[t]=r>>t&1;return e.reverse()}function I(r){return r.reduce((t,e)=>{if(e!==0&&e!==1)throw new Error(`Expected 0 or 1 as bit but got '${e}' instead`);return t<<1|e})}function x(r){if(r instanceof v)return r;let t=p(`${r}`);if(t)return t;let e=r.split("-");if(e.length!==1){if(e.length!==2)throw new Error("A range looks like 'IP-IP'");const n=p(e[0]);if(!n||!n.exact())throw new Error("Left side of the IP range isn't a valid (exact) IP");const s=p(e[1]);if(!s||!s.exact())throw new Error("Right side of the IP range isn't a valid (exact) IP");if(n.type!==s.type)throw new Error("Expected same type of IP on both sides of range");return new d(n,s)}if(e=r.split("/"),e.length!==1){if(t=p(e[0]),!t||!t.exact())throw new Error("Expected a valid (exact) IP for a subnetwork");const n=Number(e[1]);if(Number.isInteger(n))return new P(t,n);const s=p(e[1]);if(s)return new w(t,s);throw new Error("A subnetwork or mask looks like 'IP/bits' or 'IP/mask' e.g. '::1/64' or '::1/aa::'")}throw new Error("Invalid IP (range/subnetwork)")}c.getMatch=x;function S(r,t){return e=>r in e?e[r]:e[r]=t(e)}const N=Symbol("convertToMasks");function b(r){const t=S(N,r);return e=>[...t(e)]}const R=Symbol("convertToSubnet"),C=Symbol("convertToSubnets");class v{constructor(t){return t==null?this:x(t)}}c.IPMatch=v;class f extends v{constructor(t){if(super(null),this.type="IPv4",this.bits=f.bits,this.input=t.trim(),!t.match($))throw new Error("Invalid input for IPv4");this.parts=t.split(".").map(q(255))}matches(t){let e;if(t instanceof f||t instanceof u?e=t:e=p(t),!e)throw new Error("The given value is not a valid IP");if(!(e instanceof f))return!1;for(let n=0;n<4;n+=1){const s=e.parts[n],o=this.parts[n];if(o!==-1&&s!==o)return!1}return!0}equals(t){return t instanceof f&&t.parts.every((e,n)=>this.parts[n]===e)}exact(){return!this.parts.includes(-1)}toString(){return this.parts.map(t=>t===-1?"*":t).join(".")}convertToMasks(){return f.convertToMasks(this)}getAmount(){return this.parts.reduce((t,e)=>e===-1?t*256:t,1)}getPrevious(){const t=[...this.parts];for(let e=t.length-1;e>=0;e--)if(t[e]===0)t[e]=255;else if(t[e]!==-1)return t[e]--,l(t)}getNext(){const t=[...this.parts];for(let e=t.length-1;e>=0;e--)if(t[e]===255)t[e]=0;else if(t[e]!==-1)return t[e]++,l(t)}toBits(){return this.parts.reduce((t,e)=>[...t,...A(e,8)],[])}static fromBits(t){if(t.length!==32)throw new Error("Expected 32 bits for IPv4.fromBits");return l([I(t.slice(0,8)),I(t.slice(8,16)),I(t.slice(16,24)),I(t.slice(24,32))])}}c.IPv4=f;f.convertToMasks=b(r=>{if(r.exact())return[new w(r,l(r.parts.map(()=>255)))];const t=l(r.parts.map(e=>e===-1?0:e));return[new w(t,l(r.parts.map(e=>e===-1?0:255)))]});f.bits=32;const y=q(65535,16);function B(r){typeof r=="string"&&(r=new u(r)),r instanceof u&&(r=r.toHextets());const t=[0,0,0,0,0,0,0,0],{length:e}=r;for(let s=0;s<e;s+=1)for(let o=s;o<e&&r[o]==="0";o+=1)t[s]+=1;const n=t.reduce((s,o,i)=>o>t[s]?i:s,0);return t[n]&&(r.splice(n,t[n]-1),r[n]=""),r.length===1&&!r[0]?"::":r.join(":").replace(/(^:|:$)/,"::")}let L=()=>(L=()=>[x("::ffff:*:*"),x("::ffff:0:*:*")])();class u extends v{constructor(t){super(null),this.type="IPv6",this.bits=u.bits,this.input=t=t.trim();const e=t.match(M);if(e){if(e[2].includes("*"))throw new Error("Mixed IPv6 address cannot contain wildcards in IPv4 part");const{parts:s}=new f(e[2]);this.parts=[...new u(`${e[1]}:0:0`).parts.slice(0,6),(s[0]<<8)+s[1],(s[2]<<8)+s[3]];return}if(!F.test(t)&&!M.test(t))throw new Error("Invalid input for IPv6");const n=t.split("::");if(n.length>2)throw new Error("IPv6 addresses can only contain :: once");if(n.length===1)this.parts=n[0].split(":").map(y);else{const s=n[0]?n[0].split(":"):[],o=n[1]?n[1].split(":"):[],i=8-s.length-o.length;if(i===0)throw new Error("This IPv6 address doesn't need a ::");if(i<1)throw new Error("Invalid amount of :");for(let a=0;a<i;a+=1)s.push("0");this.parts=s.concat(o).map(y)}}matches(t){let e;if(t instanceof f||t instanceof u?e=t:e=p(t),!e)throw new Error("The given value is not a valid IP");if(!(e instanceof u))return!1;for(let n=0;n<8;n+=1){const s=e.parts[n],o=this.parts[n];if(o!==-1&&s!==o)return!1}return!0}equals(t){return t instanceof u&&t.parts.every((e,n)=>this.parts[n]===e)}exact(){return!this.parts.includes(-1)}toHextets(){return this.parts.map(t=>t===-1?"*":t.toString(16))}toLongString(){return this.toHextets().join(":")}toFullString(){return this.toHextets().map(t=>t!=="*"&&t.length<4?`${"0".repeat(4-t.length)}${t}`:t).join(":")}toMixedString(){const{parts:t}=this,e=t.slice(0,6).map(o=>o===-1?"*":o.toString(16));let n=B(e);n.endsWith("::")&&(n=n.substring(0,n.length-1));const s=[t[6]>>8,t[6]&255,t[7]>>8,t[7]&255];return t[6]===-1&&(s[0]=s[1]="*"),t[7]===-1&&(s[2]=s[3]="*"),`${n}:${s.join(".")}`}toString(){return L().some(t=>t.matches(this))?this.toMixedString():B(this.toHextets())}convertToMasks(){return u.convertToMasks(this)}getAmount(){return this.parts.reduce((t,e)=>e===-1?t*65536:t,1)}getPrevious(){const t=[...this.parts];for(let e=t.length-1;e>=0;e--)if(t[e]===0)t[e]=65535;else if(t[e]!==-1)return t[e]--,l(t)}getNext(){const t=[...this.parts];for(let e=t.length-1;e>=0;e--)if(t[e]===65535)t[e]=0;else if(t[e]!==-1)return t[e]++,l(t)}toBits(){return this.parts.reduce((t,e)=>[...t,...A(e,16)],[])}static fromBits(t){if(t.length!==128)throw new Error("Expected 128 bits for IPv6.fromBits");const e=[];for(let n=0;n<8;n++)e[n]=I(t.slice(n*16,(n+1)*16));return l(e)}}c.IPv6=u;u.convertToMasks=b(r=>{if(r.exact())return[new w(r,l(r.parts.map(()=>65535)))];const t=l(r.parts.map(e=>e===-1?0:e));return[new w(t,l(r.parts.map(e=>e===-1?0:65535)))]});u.bits=128;function p(r){return r instanceof f||r instanceof u?r:(r=r.trim(),$.test(r)?new f(r):F.test(r)||M.test(r)?new u(r):null)}c.getIP=p;function l(r){if(r.length!==4&&r.length!==8)throw new Error(`Expected 4 or 8 parts, got ${r.length} instead`);const t=r.length===4?new f("0.0.0.0"):new u("::");return Object.assign(t,{parts:r}),t.input=t.toString(),t}c.partsToIP=l;class d extends v{constructor(t,e){if(super(null),this.left=t,this.right=e,this.type="IPRange",t.type!==e.type)throw new Error("Expected same type of IP on both sides of range");if(!this.isLowerOrEqual(t,e))throw new Error("Left side of range should be lower than right side");this.input=t+"-"+e}matches(t){let e;if(t instanceof f||t instanceof u?e=t:e=p(t),!e)throw new Error("The given value is not a valid IP");return e.type!==this.left.type?!1:this.isLowerOrEqual(this.left,e)&&this.isLowerOrEqual(e,this.right)}equals(t){return t instanceof d&&t.left.equals(this.left)&&t.right.equals(this.right)}toString(){return this.input}convertToSubnets(){return[...d.convertToSubnets(this)]}convertToMasks(){return d.convertToMasks(this)}getAmount(){const t=this.left.parts,e=[...this.right.parts],n=2**(this.left.bits/t.length);for(let s=0;s<e.length;s++){let o=e[s]-t[s];o<0&&(o+=n,e[s-1]-=1),e[s]=o}return e.reduce((s,o)=>s*n+o,0)+1}getFirst(){return this.left}getLast(){return this.right}isLowerOrEqual(t,e){const n=t.parts,s=e.parts;for(let o=0;o<n.length;o+=1){const i=n[o],a=s[o];if(i!==a){if(i<a)return!0;if(i>a)return!1}}return!0}}c.IPRange=d;d.convertToSubnets=S(C,r=>{const t=[],{left:e,right:n}=r,s=e.bits,o=n.toBits();let i=e;for(;i&&r.isLowerOrEqual(i,n);){const a=i.toBits();let h=0;for(let g=a.length-1;g>=0&&!a[g];g--)h++;let m=0;for(let g=0;g<a.length&&a[g]===o[g];g++)m++;m=s-m;let T=0;for(let g=o.length-1;g>=0&&o[g];g--)T++;T<m&&m--;const O=s-Math.min(h,m),k=new P(i,O);t.push(k),i=k.getLast().getNext()}return t});d.convertToMasks=b(r=>r.convertToSubnets().reduce((t,e)=>[...t,...e.convertToMasks()],[]));function H(r,t,e){return t>e&&(t=e),r&Math.pow(2,e)-Math.pow(2,e-t)}function _(r,t,e){return t>e&&(t=e),r|Math.pow(2,e-t)-1}class P extends v{constructor(t,e){if(super(null),this.bits=e,this.type="IPSubnetwork",e<0||e>t.bits)throw new Error(`A ${t.type} subnetwork's bits should be in the range of 1-${t.bits}, got ${e} instead`);let n=new t.constructor(t.input),s=new t.constructor(t.input);const o=t.bits/t.parts.length;for(let i=0;i<t.parts.length;i+=1)n.parts[i]=H(t.parts[i],e,o),s.parts[i]=_(n.parts[i],e,o),e=e<=o?0:e-o;n=new t.constructor(n.toString()),s=new t.constructor(s.toString()),this.range=new d(n,s),this.input=`${n}/${this.bits}`}matches(t){return this.range.matches(t)}equals(t){return t instanceof P&&t.range.equals(this.range)}toString(){return this.input}convertToMasks(){return P.convertToMasks(this)}getAmount(){return 2**(this.range.left.bits-this.bits)}getFirst(){return this.range.left}getLast(){return this.range.right}}c.IPSubnetwork=P;P.convertToMasks=b(r=>{const{left:t}=r.range,e=[],n=t.bits/t.parts.length,s=2**n-1;let{bits:o}=r;for(;o>0;){const i=o>n?n:o,a=n-i;e.push(s>>a<<a),o=o-i}for(let i=e.length,a=t.parts.length;i<a;i++)e[i]=0;return[new w(r.range.left,l(e))]});class w extends v{constructor(t,e){if(super(null),this.ip=t,this.mask=e,this.type="IPMask",!t.exact())throw new Error("Base IP of the IPMask isn't a valid (exact) IP");if(!e.exact())throw new Error("Mask IP of the IPMask isn't a valid (exact) IP");if(t.type!==e.type)throw new Error("Expected same type of IP as base IP and mask IP to construct the mask");const n=new t.constructor(t.input),s=e.parts;n.parts.forEach((o,i)=>n.parts[i]=o&s[i]),this.ip=n,this.input=`${n}/${e}`}matches(t){const e=p(t);if(!e)throw new Error("The given value is not a valid IP");if(e.type!==this.ip.type)return!1;const{ip:{parts:n},mask:{parts:s}}=this;return e.parts.every((o,i)=>(o&s[i])===n[i])}equals(t){return t instanceof w&&t.ip.equals(this.ip)&&t.mask.equals(this.mask)}toString(){return this.input}convertToSubnet(){return w.convertToSubnet(this)}convertToMasks(){return[this]}getAmount(){return this.mask.toBits().reduce((t,e)=>e?t:t+t,1)}isSubsetOf(t){if(this.ip.type!==t.ip.type)throw new Error("Expected same type of masks (e.g. all IPv4 or all IPv6)");if(this.equals(t))return!0;if(this.getAmount()>t.getAmount())return!1;const e=this.ip.toBits(),n=this.mask.toBits(),s=t.ip.toBits(),o=t.mask.toBits();for(let i=0;i<e.length;i++)if(o[i]&&(!n[i]||e[i]!==s[i]))return!1;return!0}}c.IPMask=w;w.convertToSubnet=S(R,({ip:r,mask:t})=>{const e=r.bits/r.parts.length,n=2**e-1;let s=0,o=!1;for(const i of t.parts){if(o&&i)return;if(i===n)s+=e;else if(i)for(let a=e-1;a>=0;a--){const h=i>>a&1;if(o&&h)return;h?s++:o=!0}else o=!0}return new P(r,s)});(function(r){var t=E&&E.__createBinding||(Object.create?function(o,i,a,h){h===void 0&&(h=a),Object.defineProperty(o,h,{enumerable:!0,get:function(){return i[a]}})}:function(o,i,a,h){h===void 0&&(h=a),o[h]=i[a]}),e=E&&E.__exportStar||function(o,i){for(var a in o)a!=="default"&&!Object.prototype.hasOwnProperty.call(i,a)&&t(i,o,a)};Object.defineProperty(r,"__esModule",{value:!0}),r.matches=void 0;const n=c;e(c,r);function s(o,i){return n.getMatch(i).matches(o)}r.matches=s})(j);export{j as l};
