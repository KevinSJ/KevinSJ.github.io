import{M as V,T as j,a as J,R as T,E as ie,F as Q,b as Z,I as U,P as S,c as B,L as N,D as ee,d as p,B as ne}from"./index-8d236247.js";class A{static rotate90(e){var f;let a;for(const n of e.frames){const i=(f=a?.addFrame())!==null&&f!==void 0?f:V.fromResized(n,n.height,n.width,!0);a??(a=i);const c=n.height-1;for(let r=0;r<i.height;++r)for(let t=0;t<i.width;++t)i.setPixel(t,r,n.getPixel(r,c-t))}return a}static rotate180(e){var f;let a;for(const n of e.frames){const i=n.width-1,c=n.height-1,r=(f=a?.addFrame())!==null&&f!==void 0?f:V.from(n,!0,!0);a??(a=r);for(let t=0;t<r.height;++t)for(let d=0;d<r.width;++d)r.setPixel(d,t,n.getPixel(i-d,c-t))}return a}static rotate270(e){var f;let a;for(const n of e.frames){const i=e.width-1,c=(f=a?.addFrame())!==null&&f!==void 0?f:V.fromResized(n,n.height,n.width,!0);a??(a=c);for(let r=0;r<c.height;++r)for(let t=0;t<c.width;++t)c.setPixel(t,r,n.getPixel(i-r,t))}return a}static findTrim(e){var f,a;const n=(f=e.mode)!==null&&f!==void 0?f:j.transparent,i=(a=e.sides)!==null&&a!==void 0?a:J.all;let c=e.image.height,r=e.image.width;const t=n===j.topLeftColor?e.image.getPixel(0,0):n===j.bottomRightColor?e.image.getPixel(r-1,c-1):void 0;let d=r,s=0,l,o=0;for(let h=0;h<c;++h){let v=!0;for(let b=0;b<r;++b){const I=e.image.getPixel(b,h);(n===j.transparent&&I.a!==0||n!==j.transparent&&(t===void 0||!I.equals(t)))&&(d>b&&(d=b),s<b&&(s=b),l??(l=h),o=h,v&&(b=s,v=!1))}}return l===void 0?new T(0,0,r,c):(i&J.top||(l=0),i&J.bottom||(o=c-1),i&J.left||(d=0),i&J.right||(s=r-1),r=1+s-d,c=1+o-l,T.fromXYWH(d,l,r,c))}static bakeOrientation(e){const f=V.from(e.image);if(!e.image.exifData.imageIfd.hasOrientation||e.image.exifData.imageIfd.orientation===1)return f;switch(f.exifData=ie.from(e.image.exifData),f.exifData.imageIfd.orientation=void 0,e.image.exifData.imageIfd.orientation){case 2:return A.flipHorizontal({image:f});case 3:return A.flip({image:f,direction:Q.both});case 4:{const a=A.copyRotate({image:f,angle:180});return A.flipHorizontal({image:a})}case 5:{const a=A.copyRotate({image:f,angle:90});return A.flipHorizontal({image:a})}case 6:return A.copyRotate({image:f,angle:90});case 7:{const a=A.copyRotate({image:f,angle:-90});return A.flipHorizontal({image:a})}case 8:return A.copyRotate({image:f,angle:-90})}return f}static copyCrop(e){var f,a,n;let i=e.image;const c=(f=e.radius)!==null&&f!==void 0?f:0,r=(a=e.antialias)!==null&&a!==void 0?a:!0,t=Z.clampInt(e.rect.left,0,i.width-1),d=Z.clampInt(e.rect.top,0,i.height-1),s=t+e.rect.width>i.width?i.width-t:e.rect.width,l=d+e.rect.height>i.height?i.height-d:e.rect.height;c>0&&i.hasPalette&&(i=i.convert({numChannels:i.numChannels}));let o;const h=i.numFrames;for(let v=0;v<h;++v){const b=i.frames[v],I=(n=o?.addFrame())!==null&&n!==void 0?n:V.fromResized(b,s,l,!0);if(o??(o=I),c>0){const y=Math.round(c),k=y*y,m=t,g=d,u=t+s,P=d+l,z=m+y-1,x=g+y-1,C=u-y+1,w=g+y-1,F=u-y+1,H=P-y+1,D=m+y-1,O=P-y+1,L=b.getRange(m,g,s,l);let E;for(;E=L.next(),!E.done;){const R=E.value,_=R.x,X=R.y;let M=1;if(_<z&&X<x){if(M=U.circleTest(R,new S(z,x),k,r),M===0){I.setPixelRgba(R.x-m,R.y-g,0,0,0,0);continue}}else if(_>C&&X<w){if(M=U.circleTest(R,new S(C,w),k,r),M===0){I.setPixelRgba(R.x-m,R.y-g,0,0,0,0);continue}}else if(_>F&&X>H){if(M=U.circleTest(R,new S(F,H),k,r),M===0){I.setPixelRgba(R.x-m,R.y-g,0,0,0,0);continue}}else if(_<D&&X>O&&(M=U.circleTest(R,new S(D,O),k,r),M===0)){I.setPixelRgba(R.x-m,R.y-g,0,0,0,0);continue}M!==1?I.getPixel(R.x-m,R.y-g).setRgba(R.r,R.g,R.b,R.a*M):I.setPixel(R.x-m,R.y-g,R)}}else for(const y of I)y.set(b.getPixel(t+y.x,d+y.y))}return o}static copyCropCircle(e){var f,a,n,i,c,r,t,d;let s=e.image,l=(a=(f=e.center)===null||f===void 0?void 0:f.x)!==null&&a!==void 0?a:Math.trunc(s.width/2),o=(i=(n=e.center)===null||n===void 0?void 0:n.y)!==null&&i!==void 0?i:Math.trunc(s.height/2),h=(c=e.radius)!==null&&c!==void 0?c:Math.trunc(Math.min(s.width,s.height)/2);const v=(r=e.antialias)!==null&&r!==void 0?r:!0;l=Z.clamp(l,0,s.width-1),o=Z.clamp(o,0,s.height-1),h<1&&(h=Math.trunc(Math.min(s.width,s.height)/2));const b=l-h,I=o-h,y=h*2,k=h*h;s.hasPalette&&(s=s.convert({numChannels:4}));let m;const g=s.numFrames;for(let u=0;u<g;++u){const P=s.frames[u],z=(t=m?.addFrame())!==null&&t!==void 0?t:V.fromResized(P,y,y,!0);m??(m=z);const x=(d=P.backgroundColor)!==null&&d!==void 0?d:s.backgroundColor;x!==void 0&&z.clear(x);const C=z.height,w=h*2;for(let F=0,H=I;F<C;++F,++H)for(let D=0,O=b;D<w;++D,++O){const L=P.getPixel(O,H),E=U.circleTest(L,new S(l,o),k,v);E!==1?z.getPixel(D,F).setRgba(L.r,L.g,L.b,L.a*E):z.setPixel(D,F,L)}}return m}static copyExpandCanvas(e){var f,a;const n=(f=e.position)!==null&&f!==void 0?f:B.center;let i=e.newWidth,c=e.newHeight;const r=e.padding;if((i===void 0||c===void 0)&&r===void 0)throw new N("Either new dimensions or padding must be provided.");if(i!==void 0&&c!==void 0&&r!==void 0)throw new N("Cannot provide both new dimensions and padding.");r!==void 0&&(i=e.image.width+r*2,c=e.image.height+r*2);const t=e.image.hasPalette?e.image.convert({numChannels:e.image.numChannels}):e.image;if(i<t.width||c<t.height)throw new N("New dimensions must be larger or equal to the original image.");if(e.toImage!==void 0&&(e.toImage.width!==i||e.toImage.height!==c))throw new N("Provided image does not match the new dimensions.");const d=(a=e.toImage)!==null&&a!==void 0?a:new V({width:i,height:c,format:e.image.format});e.backgroundColor!==void 0&&d.clear(e.backgroundColor);let s=0,l=0;switch(n){case B.topLeft:s=0,l=0;break;case B.topCenter:s=Math.trunc((i-t.width)/2),l=0;break;case B.topRight:s=i-t.width,l=0;break;case B.centerLeft:s=0,l=Math.trunc((c-t.height)/2);break;case B.center:s=Math.trunc((i-t.width)/2),l=Math.trunc((c-t.height)/2);break;case B.centerRight:s=i-t.width,l=Math.trunc((c-t.height)/2);break;case B.bottomLeft:s=0,l=c-t.height;break;case B.bottomCenter:s=Math.trunc((i-t.width)/2),l=c-t.height;break;case B.bottomRight:s=i-t.width,l=c-t.height;break;default:throw new N("Invalid position provided.")}for(let o=0;o<t.numFrames;++o){o>=d.numFrames&&d.addFrame();const h=t.frames[o],v=d.frames[o];for(const b of h)s+b.x>=i||l+b.y>=c||(b.a===b.maxChannelValue?v.setPixel(s+b.x,l+b.y,b):ee.drawPixel({image:v,pos:new S(s+b.x,l+b.y),color:b}))}return d}static copyFlip(e){return A.flip({image:e.image.clone(),direction:e.direction})}static copyRectify(e){var f,a,n;const i=(f=e.interpolation)!==null&&f!==void 0?f:p.nearest,c=i!==p.nearest&&e.image.hasPalette?e.image.convert({numChannels:e.image.numChannels}):e.image;let r;for(const t of c.frames){const d=(n=(a=r?.addFrame())!==null&&a!==void 0?a:e.toImage)!==null&&n!==void 0?n:V.from(t,!0);r??(r=d);for(let s=0;s<d.height;++s){const l=s/(d.height-1);for(let o=0;o<d.width;++o){const h=o/(d.width-1),v=e.topLeft.mul((1-h)*(1-l)).add(e.topRight.mul(h*(1-l)).add(e.bottomLeft.mul((1-h)*l).add(e.bottomRight.mul(h*l)))),b=i===p.nearest?t.getPixel(Math.trunc(v.x),Math.trunc(v.y)):t.getPixelInterpolate(v.x,v.y,i);d.setPixel(o,s,b)}}}return r}static copyResize(e){var f,a;let n=e.image,i=(f=e.interpolation)!==null&&f!==void 0?f:p.nearest,c=(a=e.maintainAspect)!==null&&a!==void 0?a:!1;if(e.width===void 0&&e.height===void 0)throw new N("Invalid size. Please specify the width or height.");n.hasPalette&&(i=p.nearest),n.exifData.imageIfd.hasOrientation&&n.exifData.imageIfd.orientation!==1&&(n=A.bakeOrientation({image:n}));let r=0,t=0,d=0,s=0;if(e.width!==void 0&&e.height!==void 0&&c===!0){r=0,d=e.width;const m=n.height/n.width,g=Math.trunc(e.width*m);if(t=Math.trunc((e.height-g)/2),s=t+g,t<0||s>e.height){t=0,s=e.height;const P=n.width/n.height,z=Math.trunc(e.height*P);r=Math.trunc((e.width-z)/2),d=r+z}}else c=!1;const l=e.height===void 0||e.height<=0?Math.round(e.width*(n.height/n.width)):e.height,o=e.width===void 0||e.width<=0?Math.round(e.height*(n.width/n.height)):e.width,h=c?d-r:o,v=c?s-t:l;if(c||(r=0,d=o,t=0,s=l),o===n.width&&l===n.height)return n.clone();const b=new Int32Array(h),I=n.width/h;for(let m=0;m<h;++m)b[m]=Math.trunc(m*I);let y;const k=n.numFrames;for(let m=0;m<k;++m){const g=n.frames[m],u=V.fromResized(g,o,l,!0);y?.addFrame(u),y??(y=u);const P=g.height/v,z=g.width/h;if(c&&e.backgroundColor!==void 0&&u.clear(e.backgroundColor),i===p.average)for(let x=0;x<v;++x){const C=Math.trunc(x*P);let w=Math.trunc((x+1)*P);w===C&&w++;for(let F=0;F<h;++F){const H=Math.trunc(F*z);let D=Math.trunc((F+1)*z);D===H&&D++;let O=0,L=0,E=0,R=0,_=0;for(let X=C;X<w;++X)for(let M=H;M<D;++M,++_){const W=g.getPixel(M,X);O+=W.r,L+=W.g,E+=W.b,R+=W.a}u.setPixel(r+F,t+x,u.getColor(O/_,L/_,E/_,R/_))}}else if(i===p.nearest)if(g.hasPalette)for(let x=0;x<v;++x){const C=Math.trunc(x*P);for(let w=0;w<h;++w)u.setPixelIndex(r+w,t+x,g.getPixelIndex(b[w],C))}else for(let x=0;x<v;++x){const C=Math.trunc(x*P);for(let w=0;w<h;++w)u.setPixel(r+w,t+x,g.getPixel(b[w],C))}else for(let x=0;x<v;++x){const C=x*P;for(let w=0;w<h;++w){const F=w*z;u.setPixel(w,x,g.getPixelInterpolate(r+F,t+C,i))}}}return y}static copyResizeCropSquare(e){var f,a,n,i;const c=e.image;let r=(f=e.interpolation)!==null&&f!==void 0?f:p.nearest;const t=(a=e.radius)!==null&&a!==void 0?a:0,d=(n=e.antialias)!==null&&n!==void 0?n:!0;if(e.size<=0)throw new N("Invalid size.");c.hasPalette&&(r=p.nearest);let s=e.size,l=e.size;c.width<c.height?s=Math.trunc(e.size*(c.height/c.width)):c.width>c.height&&(l=Math.trunc(e.size*(c.width/c.height)));const o=c.height/s,h=c.width/l,v=Math.trunc((l-e.size)/2),b=Math.trunc((s-e.size)/2),I=r===p.nearest?new Int32Array(e.size):void 0;if(I!==void 0)for(let k=0;k<e.size;++k)I[k]=Math.trunc((k+v)*h);let y;for(const k of c.frames){const m=(i=y?.addFrame())!==null&&i!==void 0?i:V.fromResized(k,e.size,e.size,!0);if(y??(y=m),t>0){const g=Math.round(t),u=g*g,P=0,z=0,x=e.size-1,C=e.size-1,w=P+g-1,F=z+g-1,H=x-g+1,D=z+g-1,O=x-g+1,L=C-g+1,E=P+g-1,R=C-g+1,_=m.getRange(P,z,l,s);let X;for(;X=_.next(),!X.done;){const M=X.value,W=M.x,Y=M.y;let q=1;if(W<w&&Y<F){if(q=U.circleTest(M,new S(w,F),u,d),q===0){M.setRgba(0,0,0,0);continue}}else if(W>H&&Y<D){if(q=U.circleTest(M,new S(H,D),u,d),q===0){M.setRgba(0,0,0,0);continue}}else if(W>O&&Y>L){if(q=U.circleTest(M,new S(O,L),u,d),q===0){M.setRgba(0,0,0,0);continue}}else if(W<E&&Y>R&&(q=U.circleTest(M,new S(E,R),u,d),q===0)){M.setRgba(0,0,0,0);continue}if(r===p.nearest){const $=Math.trunc((M.y+b)*o),G=k.getPixel(I[M.x],$);M.setRgba(G.r,G.g,G.b,G.a*q)}else{const $=M.x*h,G=M.y*o,K=k.getPixelInterpolate($,G,r),te=K.a*q;M.setRgba(K.r,K.g,K.b,te)}}return m}if(r===p.nearest)for(let g=0;g<e.size;++g){const u=Math.trunc((g+b)*o);for(let P=0;P<e.size;++P)m.setPixel(P,g,k.getPixel(I[P],u))}else for(const g of m){const u=g.x*h,P=g.y*o;g.set(k.getPixelInterpolate(u,P,r))}}return y}static copyRotate(e){var f,a,n;const i=e.image;let c=(f=e.interpolation)!==null&&f!==void 0?f:p.nearest;const r=e.angle%360;if(i.hasPalette&&(c=p.nearest),r%90===0)switch(Math.trunc(r/90)){case 1:return A.rotate90(i);case 2:return A.rotate180(i);case 3:return A.rotate270(i);default:return V.from(i)}const t=r*Math.PI/180,d=Math.cos(t),s=Math.sin(t),l=Math.abs(i.width*d),o=Math.abs(i.width*s),h=Math.abs(i.height*s),v=Math.abs(i.height*d),b=.5*i.width,I=.5*i.height,y=.5*(l+h),k=.5*(o+v);let m;const g=i.numFrames;for(let u=0;u<g;++u){const P=i.frames[u],z=(a=m?.addFrame())!==null&&a!==void 0?a:V.fromResized(i,Math.trunc(l+h),Math.trunc(o+v),!0);m??(m=z);const x=(n=P.backgroundColor)!==null&&n!==void 0?n:i.backgroundColor;x!==void 0&&z.clear(x);for(const C of z){const w=C.x,F=C.y,H=b+(w-y)*d+(F-k)*s,D=I-(w-y)*s+(F-k)*d;if(P.isBoundsSafe(H,D)){const O=P.getPixelInterpolate(H,D,c);z.setPixel(w,F,O)}}}return m}static flip(e){switch(e.direction){case Q.horizontal:A.flipHorizontal(e);break;case Q.vertical:A.flipVertical(e);break;case Q.both:A.flipHorizontalVertical(e);break}return e.image}static flipVertical(e){const f=e.image.numFrames;for(let a=0;a<f;++a){const n=e.image.frames[a],i=n.width,c=n.height,r=Math.trunc(c/2);if(e.image.hasPalette)for(let t=0,d=c-1;t<r;++t,--d)for(let s=0;s<i;++s){const l=n.getPixel(s,t),o=n.getPixel(s,d),h=l.index;l.index=o.index,o.index=h}else for(let t=0,d=c-1;t<r;++t,--d)for(let s=0;s<i;++s){const l=n.getPixel(s,t),o=n.getPixel(s,d);let h=l.r;l.r=o.r,o.r=h,h=l.g,l.g=o.g,o.g=h,h=l.b,l.b=o.b,o.b=h,h=l.a,l.a=o.a,o.a=h}}return e.image}static flipHorizontal(e){const f=e.image.numFrames;for(let a=0;a<f;++a){const n=e.image.frames[a],i=n.width,c=n.height,r=Math.trunc(i/2);if(e.image.hasPalette)for(let t=0;t<c;++t)for(let d=0,s=i-1;d<r;++d,--s){const l=n.getPixel(d,t),o=n.getPixel(s,t),h=l.index;l.index=o.index,o.index=h}else for(let t=0;t<c;++t)for(let d=0,s=i-1;d<r;++d,--s){const l=n.getPixel(d,t),o=n.getPixel(s,t);let h=l.r;l.r=o.r,o.r=h,h=l.g,l.g=o.g,o.g=h,h=l.b,l.b=o.b,o.b=h,h=l.a,l.a=o.a,o.a=h}}return e.image}static flipHorizontalVertical(e){const f=e.image.numFrames;for(let a=0;a<f;++a){const n=e.image.frames[a],i=n.width,c=n.height,r=Math.trunc(c/2);if(n.hasPalette)for(let t=0,d=c-1;t<r;++t,--d)for(let s=0,l=i-1;s<i;++s,--l){const o=n.getPixel(s,t),h=n.getPixel(l,d),v=o.index;o.index=h.index,h.index=v}else for(let t=0,d=c-1;t<r;++t,--d)for(let s=0,l=i-1;s<i;++s,--l){const o=n.getPixel(s,t),h=n.getPixel(l,d);let v=o.r;o.r=h.r,h.r=v,v=o.g,o.g=h.g,h.g=v,v=o.b,o.b=h.b,h.b=v,v=o.a,o.a=h.a,h.a=v}}return e.image}static trim(e){var f,a,n;const i=(f=e.mode)!==null&&f!==void 0?f:j.topLeftColor,c=(a=e.sides)!==null&&a!==void 0?a:J.all;if(i===j.transparent&&e.image.numChannels===3)return V.from(e.image);const r=A.findTrim({image:e.image,mode:i,sides:c});let t;for(const d of e.image.frames){const s=(n=t?.addFrame())!==null&&n!==void 0?n:V.fromResized(d,r.width,r.height,!0);t??(t=s),ee.compositeImage({dst:s,src:e.image,srcX:r.left,srcY:r.top,srcW:r.width,srcH:r.height,blend:ne.direct})}return t}static resize(e){var f;let a=e.image,n=e.width,i=e.height,c=e.maintainAspect,r=(f=e.interpolation)!==null&&f!==void 0?f:p.nearest;if(n===void 0&&i===void 0)throw new N("Invalid size");a.hasPalette&&(r=p.nearest),a.exifData.imageIfd.hasOrientation&&a.exifData.imageIfd.orientation!==1&&(a=A.bakeOrientation({image:a}));let t=0,d=0,s=0,l=0;if(n!==void 0&&i!==void 0&&c===!0){t=0,s=n;const m=a.height/a.width,g=Math.trunc(n*m);if(d=Math.trunc((i-g)/2),l=d+g,d<0||l>i){d=0,l=i;const P=a.width/a.height,z=Math.trunc(i*P);t=Math.trunc((n-z)/2),s=t+z}}else c=!1;(i===void 0||i<=0)&&(i=Math.round(n*(a.height/a.width))),(n===void 0||n<=0)&&(n=Math.round(i*(a.width/a.height)));const o=c?s-t:n,h=c?l-d:i;if(c||(t=0,s=n,d=0,l=i),n===a.width&&i===a.height)return a;if(n*i>a.width*a.height)return A.copyResize({image:a,width:n,height:i,maintainAspect:c,backgroundColor:e.backgroundColor,interpolation:r});const v=new Int32Array(o),b=a.width/o;for(let m=0;m<o;++m)v[m]=Math.trunc(m*b);const I=a.width,y=a.height,k=a.numFrames;for(let m=0;m<k;++m){const g=a.frames[m],u=g,P=g.height/h,z=g.width/o;if(c&&e.backgroundColor!==void 0&&u.clear(e.backgroundColor),r===p.average)for(let x=0;x<h;++x){const C=Math.trunc(x*P);let w=Math.trunc((x+1)*P);w===C&&w++;for(let F=0;F<o;++F){const H=Math.trunc(F*z);let D=Math.trunc((F+1)*z);D===H&&D++;let O=0,L=0,E=0,R=0,_=0;for(let M=C;M<w;++M)for(let W=H;W<D;++W,++_){const Y=g.getPixel(W,M);O+=Y.r,L+=Y.g,E+=Y.b,R+=Y.a}const X=u.getColor(O/_,L/_,E/_,R/_);u.data.width=n,u.data.height=i,u.setPixel(t+F,d+x,X),u.data.width=I,u.data.height=y}}else if(r===p.nearest)if(g.hasPalette)for(let x=0;x<h;++x){const C=Math.trunc(x*P);for(let w=0;w<o;++w){const F=g.getPixelIndex(v[w],C);u.data.width=n,u.data.height=i,u.setPixelIndex(t+w,d+x,F),u.data.width=I,u.data.height=y}}else for(let x=0;x<h;++x){const C=Math.trunc(x*P);for(let w=0;w<o;++w){const F=g.getPixel(v[w],C);u.data.width=n,u.data.height=i,u.setPixel(t+w,d+x,F),u.data.width=I,u.data.height=y}}else for(let x=0;x<h;++x){const C=x*P;for(let w=0;w<o;++w){const F=w*z,H=g.getPixelInterpolate(t+F,d+C,r);u.data.width=n,u.data.height=i,u.setPixel(w,x,H),u.data.width=I,u.data.height=y}}u.data.width=n,u.data.height=i}return a}}export{A as T};
