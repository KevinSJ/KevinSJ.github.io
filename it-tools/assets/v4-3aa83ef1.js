const e=[];for(let n=0;n<256;++n)e.push((n+256).toString(16).slice(1));function c(n,t=0){return(e[n[t+0]]+e[n[t+1]]+e[n[t+2]]+e[n[t+3]]+"-"+e[n[t+4]]+e[n[t+5]]+"-"+e[n[t+6]]+e[n[t+7]]+"-"+e[n[t+8]]+e[n[t+9]]+"-"+e[n[t+10]]+e[n[t+11]]+e[n[t+12]]+e[n[t+13]]+e[n[t+14]]+e[n[t+15]]).toLowerCase()}let o;const y=new Uint8Array(16);function g(){if(!o){if(typeof crypto>"u"||!crypto.getRandomValues)throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");o=crypto.getRandomValues.bind(crypto)}return o(y)}const m=typeof crypto<"u"&&crypto.randomUUID&&crypto.randomUUID.bind(crypto),i={randomUUID:m};function p(n,t,r){n=n||{};const u=n.random??n.rng?.()??g();if(u.length<16)throw new Error("Random bytes length must be >= 16");if(u[6]=u[6]&15|64,u[8]=u[8]&63|128,t){if(r=r||0,r<0||r+16>t.length)throw new RangeError(`UUID byte range ${r}:${r+15} is out of buffer bounds`);for(let d=0;d<16;++d)t[r+d]=u[d];return t}return c(u)}function U(n,t,r){return i.randomUUID&&!t&&!n?i.randomUUID():p(n,t,r)}export{g as r,c as u,U as v};
